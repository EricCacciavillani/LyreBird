from music21 import converter, instrument, note, chord, midi, stream
import numpy as np
import shelve
from keras.models import load_model
import sys
import string
import random
import zlib
import _pickle as cPickle
import zlib

shelf = shelve.open('/home/eric/Desktop/LyreBird/Main_Production/Saved_Models/LSTM_Models/LSTM_Data_Dump/' + sys.argv[1] + '_Music_LSTM_Model')
backward_dict = shelf['backward_dict']
input_notes = cPickle.loads(zlib.decompress(shelf['input_notes']))
vocab_length = shelf['vocab_length']
sequence_length = shelf['sequence_length']

shelf.close()
#
model = load_model('/home/eric/Desktop/LyreBird/Main_Production/Saved_Models/LSTM_Models/' + sys.argv[1] + '_Music_LSTM_Model.h5')

# pick a random sequence from the input as a starting point for the prediction
n = np.random.randint(0, len(input_notes)-1)
sequence = input_notes[n]
start_sequence = sequence.reshape(1, sequence_length, vocab_length)
output = []

# Let's generate a song of 100 notes
for i in range(0, 200):
    newNote = model.predict(start_sequence, verbose=0)
    # Get the position with the highest probability
    index = np.argmax(newNote)
    encoded_note = np.zeros((vocab_length))
    encoded_note[index] = 1
    output.append(encoded_note)
    sequence = start_sequence[0][1:]
    start_sequence = np.concatenate((sequence, encoded_note.reshape(1, vocab_length)))
    start_sequence = start_sequence.reshape(1, sequence_length, vocab_length)

# ### Convert to MIDI format
# Code here to output to MIDI files taken
# from github repo https://github.com/Skuldur/Classical-Piano-Composer.

finalNotes = []
for element in output:
    index = list(element).index(1)
    finalNotes.append(backward_dict[index])

offset = 0
output_notes = []

# create note and chord objects based on the values generated by the model
for pattern in finalNotes:
    # pattern is a chord
    if ('.' in pattern) or pattern.isdigit():
        notes_in_chord = pattern.split('.')
        notes = []
        for current_note in notes_in_chord:
            new_note = note.Note(int(current_note))
            new_note.storedInstrument = instrument.Piano()
            notes.append(new_note)
        new_chord = chord.Chord(notes)
        new_chord.offset = offset
        output_notes.append(new_chord)
    # pattern is a note
    else:
        new_note = note.Note(pattern)
        new_note.offset = offset
        new_note.storedInstrument = instrument.Piano()
        output_notes.append(new_note)

    # increase offset each iteration so that notes do not stack
    offset += 0.5

midi_stream = stream.Stream(output_notes)

music_id = "".join([random.choice(string.ascii_letters + string.digits) for n in range(10)])
midi_stream.write('midi', fp='/home/eric/Desktop/LyreBird/Main_Production/Model_Song_Outputs/LSTM_Outputs/' + sys.argv[1] + "_Music_" + music_id + ".mid")